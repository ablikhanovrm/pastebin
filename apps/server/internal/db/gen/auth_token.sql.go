// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth_token.sql

package dbgen

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (user_id, token_hash, user_agent, ip_address, expires_at) VALUES ($1,$2,$3,$4,$5) RETURNING id, created_at
`

type CreateRefreshTokenParams struct {
	UserID    int64
	TokenHash string
	UserAgent pgtype.Text
	IpAddress *netip.Addr
	ExpiresAt pgtype.Timestamptz
}

type CreateRefreshTokenRow struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (CreateRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.UserID,
		arg.TokenHash,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i CreateRefreshTokenRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const getRefreshTokenByHash = `-- name: GetRefreshTokenByHash :one
SELECT r.user_id, r.token_hash, r.user_agent, r.ip_address, r.expires_at 
FROM refresh_tokens AS r
WHERE r.token_hash = $1 AND r.revoked = false
`

type GetRefreshTokenByHashRow struct {
	UserID    int64
	TokenHash string
	UserAgent pgtype.Text
	IpAddress *netip.Addr
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (GetRefreshTokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByHash, tokenHash)
	var i GetRefreshTokenByHashRow
	err := row.Scan(
		&i.UserID,
		&i.TokenHash,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
	)
	return i, err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens 
SET revoked = true, revoked_at = NOW()
WHERE token_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, tokenHash)
	return err
}
